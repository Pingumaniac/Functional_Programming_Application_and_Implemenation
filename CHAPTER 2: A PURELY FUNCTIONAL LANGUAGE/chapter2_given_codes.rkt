#lang racket

(define (first x)
  (car x))
(define (second x)
  (cadr x))
(define (third x)
  (caddr x))
(define (topleft s)
  (first (first s)))
(define (topright s)
  (second (first s)))
(define (bottomleft s)
  (first (second s)))
(define (bottomright s)
  (second (second s)))
(define (atom? x)
  (not (pair? x)))
(define (f x)
  (if (atom? x)
      null
      (car x)))
(define (size x)
  (if (eq? x null)
      0
      (if (eq? (cdr x) null)
          1
          2)))
(define (x-rem-y x y)
  (- x (* (/ x y) y)))
(define (quotrem x y)
  (list (/ x y) (x-rem-y x y)))
(define (distance x y)
  (if (<= x y)
      (- y x)
      (- x y)))
(define (length x)
  (if (eq? x null)
      0
      (+ (length (cdr x)) 1)))
(define (sum x)
  (if (eq? x null)
      0
      (+ (car x) (sum (cdr x)))))
(define (append x y)
  (if (eq? x null)
      y
      (cons (car x) (append (cdr x) y))))
(define (append-2 x y)
  (if (eq? x null)
      y
      (cons (car x) (append-2 (cdr x) y))))
(define (reverse x)
  (if (eq? x null)
      null
      (append (reverse (cdr x)) (cons (car x) null))))
(define (atomsin t)
  (if (eq? t null)
      null
      (if (atom? (car t))
          (addtoset (atomsin (cdr t)) (car t))
          (union (atomsin (car t)) (atomsin (cdr t))))))
(define (union u v)
  (if (eq? u null)
      v
      (addtoset (union (cdr u) v) (car u))))
(define (addtoset s x)
  (if (member x s)
      s
      (cons x s)))
(define (member x s)
  (if (eq? s null)
      #f
      (if (eq? x (car s))
          #t
          (member x (cdr s)))))
(define (rev x)
  (append (reverse x) null))
(define (twolist a b)
  (list a b))
(define (sumprod x)
  (if (null? x)
      (twolist 0 1)
      (accumulate (car x) (sumprod (cdr x)))))
(define (accumulate n z)
  (twolist (+ n (car z)) (* n (cadr z))))
(define (prod u v) (list 'MUL u v))
(define (diff e)
  (cond ((atom? e)
         (if (eq? e 'X)
             1
             0))
        ((eq? (car e) 'ADD)
         (let ((e1 (cadr e))
               (e2 (caddr e)))
           (sum (diff e1) (diff e2))))
        ((eq? (car e) 'MUL)
         (let ((e1 (cadr e))
               (e2 (caddr e)))
           (sum (prod (diff e1) e2) (prod e1 (diff e2)))))
        (else
         (error "Invalid expression"))))
(define (map x f)
  (if (null? x)
      '()
      (cons (f (car x)) (map (cdr x) f))))
(define (inc1 z)
  (+ z 1))
(define (inclist x)
  (map x inc1))
(define (rem2 z)
  (modulo z 2))
(define remlist (lambda (x) (map x rem2)))
(define (reduce x g a)
  (if (null? x)
      a
      (g (car x) (reduce (cdr x) g a))))
(define (atomsize s)
  (if (atom? s)
      1
      (+ (atomsize (car s)) (atomsize (cdr s)))))
(define (equal x y)
  (cond ((atom? x) (eq? x y))
        ((atom? y) #f)
        (else (and (equal (car x) (car y))
                   (equal (cdr x) (cdr y))))))


